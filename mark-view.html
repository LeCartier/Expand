<html>
  <head>
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <!-- we import arjs version without NFT but with marker + location based support -->
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
    <!-- Supabase JS v2 -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <!-- Central config -->
    <script src="config.js"></script>
    <style>
      #loadingOverlay {
        position: fixed;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 10px 20px;
        border-radius: 20px;
        font-family: system-ui, sans-serif;
        font-size: 14px;
        z-index: 9999;
        display: none;
      }
      #loadingOverlay.show {
        display: block;
      }
      #loadingOverlay.error {
        background: rgba(220, 38, 38, 0.9);
      }
      #loadingOverlay.success {
        background: rgba(34, 197, 94, 0.9);
      }
    </style>
  </head>
  <body style="margin : 0px; overflow: hidden;">
    <div id="loadingOverlay">Loading model...</div>
    <a-scene a-scene embedded arjs="sourceType: webcam; sourceWidth:1280; sourceHeight:960; displayWidth: 1280; displayHeight: 960;">
      <a-marker type="pattern" preset="custom" url="FFE.patt" emitevents="true" smooth="true">
        <a-entity
          id="mark-model-entity"
          position="0 0 0"
          scale="0.75 0.75 0.75"
          touch-gestures
        ></a-entity>
      </a-marker>
      <a-entity camera></a-entity>
    </a-scene>

    <script>
      const { SUPABASE_URL, SUPABASE_ANON_KEY } = window.APP_CONFIG || {};

      if (SUPABASE_URL && SUPABASE_ANON_KEY && window.supabase) {
        const supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        function getIdFromQuery() {
          const params = new URLSearchParams(window.location.search);
          const raw = params.get('id');
          return raw ? raw.trim() : '';
        }

        async function initMarkerModelFromSupabase() {
          const qrId = getIdFromQuery();
          const overlay = document.getElementById('loadingOverlay');
          
          if (!qrId) {
            console.warn('No QR id found in URL');
            overlay.textContent = 'No QR code ID in URL';
            overlay.className = 'show error';
            return;
          }

          overlay.textContent = 'Loading model...';
          overlay.className = 'show';

          try {
            const { data, error } = await supabaseClient
              .from('qr_models')
              .select('glb_url')
              .eq('id', qrId)
              .maybeSingle();

            if (error) {
              console.error('Supabase query error:', error);
              overlay.textContent = 'Database error';
              overlay.className = 'show error';
              return;
            }

            if (!data || !data.glb_url) {
              console.warn('No GLB URL found for id:', qrId);
              overlay.textContent = 'No model found for this QR';
              overlay.className = 'show error';
              return;
            }

            const modelEntity = document.getElementById('mark-model-entity');
            if (!modelEntity) {
              console.error('Model entity not found');
              overlay.textContent = 'AR viewer error';
              overlay.className = 'show error';
              return;
            }

            console.log('Loading GLB from:', data.glb_url);

            // Add event listeners to monitor model loading
            modelEntity.addEventListener('model-loaded', function () {
              console.log('✓ Model loaded successfully');
              overlay.textContent = '✓ Model loaded - Point at QR marker';
              overlay.className = 'show success';
              
              // Hide overlay after 3 seconds
              setTimeout(() => {
                overlay.className = '';
              }, 3000);
              
              // After model loads, check and log its actual size
              const mesh = modelEntity.getObject3D('mesh');
              if (mesh) {
                const box = new THREE.Box3().setFromObject(mesh);
                const size = box.getSize(new THREE.Vector3());
                const center = box.getCenter(new THREE.Vector3());
                
                console.log('=== MODEL DEBUG INFO ===');
                console.log('Model dimensions (width, height, depth):', size.x.toFixed(3), size.y.toFixed(3), size.z.toFixed(3));
                console.log('Model center offset:', center.x.toFixed(3), center.y.toFixed(3), center.z.toFixed(3));
                console.log('Current position:', modelEntity.getAttribute('position'));
                console.log('Current scale:', modelEntity.getAttribute('scale'));
                console.log('Current rotation:', modelEntity.getAttribute('rotation'));
                
                // Calculate appropriate scale based on largest dimension
                const maxDimension = Math.max(size.x, size.y, size.z);
                console.log('Max dimension:', maxDimension.toFixed(3));
                
                // Target size: 1 unit (marker is typically 1 unit)
                const targetSize = 1.0;
                const calculatedScale = targetSize / maxDimension;
                
                console.log('Calculated scale needed:', calculatedScale.toFixed(3));
                
                // Apply the calculated scale
                modelEntity.setAttribute('scale', {
                  x: calculatedScale,
                  y: calculatedScale,
                  z: calculatedScale
                });
                
                // Center the model if it has offset
                // Move model so its center is at the marker origin
                modelEntity.setAttribute('position', {
                  x: -center.x * calculatedScale,
                  y: -center.y * calculatedScale,
                  z: -center.z * calculatedScale
                });
                
                console.log('Applied scale:', calculatedScale.toFixed(3));
                console.log('Applied centering position:', 
                  (-center.x * calculatedScale).toFixed(3),
                  (-center.y * calculatedScale).toFixed(3),
                  (-center.z * calculatedScale).toFixed(3)
                );
                console.log('======================');
              } else {
                console.warn('No mesh found in model entity');
              }
            });

            modelEntity.addEventListener('model-error', function (evt) {
              console.error('✗ Model failed to load:', evt.detail);
              overlay.textContent = '✗ Model failed to load';
              overlay.className = 'show error';
            });

            // Set the model URL
            modelEntity.setAttribute('gltf-model', data.glb_url);

          } catch (e) {
            console.error('Error loading marker model from Supabase:', e);
            overlay.textContent = 'Error: ' + e.message;
            overlay.className = 'show error';
          }
        }

        // Wait for A-Frame to be ready before loading model
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', initMarkerModelFromSupabase);
        } else {
          initMarkerModelFromSupabase();
        }
      }
    </script>
    <script>
      // A-Frame component for basic touch gestures: drag to rotate, pinch to scale
      AFRAME.registerComponent('touch-gestures', {
        schema: {
          minScale: { default: 0.1 },
          maxScale: { default: 3.0 },
          rotationFactor: { default: 0.5 }, // degrees per px
          scaleFactor: { default: 0.005 }   // scale per px distance change
        },
        init: function () {
          this.touchState = {
            isDragging: false,
            isPinching: false,
            startRotationY: 0,
            lastTouchX: 0,
            startDistance: 0,
            startScale: 1
          };

          const sceneEl = this.el.sceneEl;
          this._onTouchStart = this.onTouchStart.bind(this);
          this._onTouchMove = this.onTouchMove.bind(this);
          this._onTouchEnd = this.onTouchEnd.bind(this);

          sceneEl.canvas?.addEventListener('touchstart', this._onTouchStart, { passive: false });
          sceneEl.canvas?.addEventListener('touchmove', this._onTouchMove, { passive: false });
          sceneEl.canvas?.addEventListener('touchend', this._onTouchEnd, { passive: false });
          sceneEl.canvas?.addEventListener('touchcancel', this._onTouchEnd, { passive: false });
        },
        remove: function () {
          const sceneEl = this.el.sceneEl;
          sceneEl.canvas?.removeEventListener('touchstart', this._onTouchStart);
          sceneEl.canvas?.removeEventListener('touchmove', this._onTouchMove);
          sceneEl.canvas?.removeEventListener('touchend', this._onTouchEnd);
          sceneEl.canvas?.removeEventListener('touchcancel', this._onTouchEnd);
        },
        getTouches: function (e) {
          return e.touches || e.changedTouches || [];
        },
        onTouchStart: function (e) {
          const touches = this.getTouches(e);
          if (touches.length === 1) {
            this.touchState.isDragging = true;
            this.touchState.isPinching = false;
            this.touchState.lastTouchX = touches[0].clientX;
            const rot = this.el.getAttribute('rotation') || { x: 0, y: 0, z: 0 };
            this.touchState.startRotationY = rot.y;
          } else if (touches.length === 2) {
            this.touchState.isDragging = false;
            this.touchState.isPinching = true;
            this.touchState.startDistance = this.getDistance(touches[0], touches[1]);
            const scale = this.el.getAttribute('scale') || { x: 1, y: 1, z: 1 };
            this.touchState.startScale = scale.x; // uniform scale assumed
          }
        },
        onTouchMove: function (e) {
          const touches = this.getTouches(e);
          if (this.touchState.isDragging && touches.length === 1) {
            e.preventDefault();
            const dx = touches[0].clientX - this.touchState.lastTouchX;
            const rotY = this.touchState.startRotationY + dx * this.data.rotationFactor;
            this.el.setAttribute('rotation', { x: 0, y: rotY, z: 0 });
          } else if (this.touchState.isPinching && touches.length === 2) {
            e.preventDefault();
            const newDist = this.getDistance(touches[0], touches[1]);
            const delta = newDist - this.touchState.startDistance;
            let newScale = this.touchState.startScale + delta * this.data.scaleFactor;
            newScale = Math.max(this.data.minScale, Math.min(this.data.maxScale, newScale));
            this.el.setAttribute('scale', { x: newScale, y: newScale, z: newScale });
          }
        },
        onTouchEnd: function () {
          this.touchState.isDragging = false;
          this.touchState.isPinching = false;
        },
        getDistance: function (t1, t2) {
          const dx = t1.clientX - t2.clientX;
          const dy = t1.clientY - t2.clientY;
          return Math.sqrt(dx * dx + dy * dy);
        }
      });
    </script>
  </body>
</html>